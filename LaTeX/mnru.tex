
%=============================================================================
% ... THIS IS chapter{Duo-MNRU: The ITU-T Modulated Noise Reference Unit } ...
% Revisions
% Nov.1995 - Simao Campos
% Jan.1996 - Peter Kroon, Simao Campos, Paul Voros, Rosario D. de Iacovo,
% Apr.1996 - Mark Perkins
% Feb.2000 - Convergence towards STL2000
% Feb.2001 - Edits in example section
% Apr.2005 - Updates for STL2005 (Cyril Guillaumé & Stéphane Ragot)
% Oct.2005 - Editorial changes for STL2005 (Simao Campos)
% May.2013 - Mention about problems on applying to SWB signal
%=============================================================================
%=============================================================================
\chapter{Duo-MNRU: The Dual-mode Modulated Noise Reference Unit}
%=============================================================================

For evaluation of the quality of a system or equipment, it is
important to express the quality measure in a unit suitable for
comparison with other reference (or well-known) equipments and
systems. A common way of representing these figures is by means of
relative units, where the quality is expressed by means of a unique
figure, in a unidimensional scale.

But it is insuficient to be unidimensional; the scale must be
inequivocal, with a universal meaning. As an example, the ACR scale ({\em
Absolute Category Rating}, \cite[Annex B]{P.800}), which is a scale
used for listening opinion tests and has five points termed {\em
Excellent}, {\em Good}, {\em Fair}, {\em Poor}, and {\em Bad}, is
inadequate: besides it shows a continuum of quality points, the meaning
of the adjectives are far from universal, varying from language to
language, and from person to person. Exchange of information on the
performance of these systems and equipments is easier and more
consistent with more objective measures. The issue of how the MNRU is
to be used as a reference system in subjective tests has been studied
in ITU-T Study Group 12, which is described in
\textcolor{blue}{Recommendation ITU-T} P.830 \cite{P.830} in its Sections 8.2.2 and 11.

The Modulated Noise Reference Unity (MNRU) was introduced as a means
to controlled degradations that are representative of the non-linear
distortion introduced by waveform coding techniques. Initially aiming
at evaluating the quality of log-PCM waveform coding systems, it has
been used in the process of generating several ITU-T standards, such
as the ITU-T G.726 (32 kbit/s), G.722, G.728, and G.729.

The concept of such reference unit was published in
\cite{Q001.02.04.02}.  The first system aimed at was the PCM coding
with logarithmic compression (today world-wide available by means of
the \textcolor{blue}{Recommendation ITU-T} G.711), whose main characteristic is to have a
considerably uniform signal-to-noise ratio (SNR) over a wide range of
amplitudes.  Moreover, the quantizing noise is correlated to the
signal: if no signal is present, no quantization noise is
produced\footnote{\SF This is obviously academic, because always there
will be idle noise, among others, in the absence of an input signal.},
and large signals will produce more quantization noise than small
ones. Therefore, the main characteristic of this reference unit should
output speech corrupted by a speech-correlated noise.

%------------------------------------------------------------------------
% P.81 narrow-band MNRU
% The box y-length has been decreased by 1cm and the ps data
%  shifted down by ~1cm (-18 points)
%------------------------------------------------------------------------
 \begin{figure}[hpbt]
  \begin{center}
    \includegraphics{p81-dig}
  \end{center}
  \caption{Block diagram of the ``digital'' MNRU. The bandwidth of the
           output filter $h(k)$ is 0--3400 Hz for the narrowband
           case, and 0--7000 Hz for the wideband case.
           \label{1/P.810}}
 \end{figure}
%------------------------------------------------------------------------

In \cite{Q001.02.04.02}, the speech-correlated noise generation was
based on a double-balanced ring modulator, controlled by the input
speech signal, which modulates a noise carrier generated by a noise
generator having a relatively uniform energy distribution, there in the range
of 0--20kHz. This correlated noise is then added to the input signal, with
gains applied such that a controlled signal-to-noise ratio is obtained
in the output, after the 300--3400Hz band-limiting filter.

With the 1996 revision of the MNRU description published in 
\textcolor{blue}{Recommendation ITU-T} P.810\footnote{\SF Formerly known as
\textcolor{blue}{Recommendation ITU-T} P.81.}, specific guidelines were given for ``digital
implementations''\footnote{\SF The revised P.81 define a ``digital
implementation'' either as a digital hardware implementation or as a
software implementation of the MNRU.}, eliminating many of the
ambiguities possible in earlier descriptions \cite{Old-P.81}, as
explained in the STL92 manual \cite[Chapter 8]{STL92-Manual}. Figure
\ref{1/P.810} shows a block diagram of the ``digital'' MNRU. Also,
this implementation allows for transparent operation on narrowband
or wideband speech, hence being known as Dual-mode MNRU, or
``Duo-MNRU'', for short.

\textcolor{blue}{%
  Special caution must be made when selecting frequency bandwidth of
  the input signal. The current implementation of tool is only useful
  for narrowband (200 -- 3400 Hz) and wideband (100 -- 7000 Hz) signal
  only, and should not be applied to superwideband or fullband signal.
%
}

\section{Description of the Algorithm}

The de-facto reference implementation of the MNRU\footnote{\SF
Developed by the British Telecom and licenced to Malden
Electronics.} is the same of the original description, whose
specification can be found in \textcolor{blue}{Recommendation ITU-T} P.810
\cite{P.810} (formerly \textcolor{blue}{Recommendation ITU-T} P.81 \cite{Old-P.81}).
This Recommendation describes two MNRU schemes, one called {\em
Narrow-band MNRU}, and another, {\em Wideband MNRU}. Wideband MNRU
is applicable to systems where wideband speech (70--7000Hz) is
expected, whereas Narrow-band MNRU is for telephone bandwidth
(300--3400Hz). Both narrowband and wideband MNRUs are implemented in
this version of the ITU-T Software Tools Library.

The basic block diagram of the P.810 MNRU is found in figure
\ref{1/P.810}. In summary, there are two paths, one called {\em signal
path}, another called {\em noise path}. In the noise path, gaussian
noise (uniform in a range at least the cutoff frequency of the
low-pass filter in the output of the MNRU) is modulated by the
incoming signal. The result is then added with the output from the
signal path. The gains are set such that the gain (in dB) applied in
the output of the noise path is the signal-to-correlated-noise ratio
$Q$, in the output of the band-pass filter, as calculated in the
section to follow.

In analytical terms, the signal corrupted by the modulated noise $y(k)$ is
\[
       y(k) = (G_s x(k) + G_n x(k) n(k)) \ast h(k)
\]
where $G_s$ is the gain of the signal path, $G_n$ is the gain of the
noise path, $x(k)$ is the input signal, and $n(k)$ is the gaussian
noise signal; the symbol $\ast$ means convolution, and $h(k)$ is the
band-pass filter.

If we suppose that the band-pass filter has $|H(f)|=1$ in its pass
band, and calling $Q$ the signal-to-noise-ratio (SNR) at its output,
we may write:
\[
    10^{Q/10} = \frac{\sigma^2_\xi}{\sigma^2_\nu} =
                \frac{E[\xi^2(k)]}{E[\nu^2(k)]}=
                \frac{G^2_s E[x^2(k)]}{G^2_n E[x^2(k) n^2(k)]}
\]
But $x$ and $n$ are uncorrelated, and the noise is gaussian with mean 0
and variance 1 (N(0,1)):
\[
    10^{Q/10} = \left( \frac{G_s}{G_n} \right)^2
                \frac{\sigma^2_x}{\sigma^2_x \sigma^2_n} =
                \left( \frac{G_s}{G_n} \right)^2
\]
or
\[
\begin{array}{lll}
     Q &= &\Gamma_s + \Gamma_n \\
     \Gamma_s &= &20 \log_{10}(G_s)\\
     \Gamma_n &= &-20 \log_{10}(G_n)
\end{array}
\]

If we set $\Gamma_s=0$ ($G_s=1$), $Q$ is exactly $\Gamma_n$ (or,
$G_n=10^{-Q/20}$), i.e., the SNR is the gain (in dB) of the noise path
and the previous expression may be written as:
\[
y(k)=[x(n)+10^{-Q/20} x(k) n(k)] \ast h(k)
\]
or approximately
\[
y(k)=x(k)+10^{-Q/20} x(k) n(k)
\]
in the passband region of $H(f)|$.

When both $G_s$ and $G_n$ are non-zero, the MNRU is in an operational
mode normally called {\em Modulated-noise mode}. This is the most
common operation mode.

Alternatively, if one consider $G_s=0$, the output of the algorithm is
only the correlated noise, at a level $Q$ dB below the input signal.
This is {\em Noise-only mode}.

If, on the other hand, $G_n=0$, the output of the algorithm is the
input signal filtered by $h(k)$, with a gain $G_s$; this is the {\em
Signal-only mode}.


\section{Implementation}

This implementation of the MNRU algorithm can be found in the module
{\tt mnru.c}, with prototypes in {\tt mnru.h}. A thorough
characterization of this module is presented in \cite{Duo-MNRU}. The
previous version of the ITU-T STL MNRU was applicable to narrowband
signals and evolved from a Fortran implementation which had been used
by several laboratories, especially by participants of ETSI's
contest for the second generation of Digital Mobile Radio Systems,
and was originally written by experts at CSELT/Italy (sometimes
referred as {\em CSELT MNRU}), an implementation fully compliant with
the narrowband MNRU specification available in the then-in-force P.81
\cite{Old-P.81}.

With the revision of MNRU specification, several changes had to be
made to the STL92 MNRU:
\begin{itemize}
  \item The need for an upsampling by a factor of 5 before summation
        of the modulated noise to the input speech was eliminated
        because now for digital implementations, the bandwidth of the
        multiplicative noise shall have the bandwidth of the input
        signal. In the previous version, the noise bandwidth had to be
        20 kHz.
  \item The output filter for digital implementations shall be a
        low-pass filter, instead of the bandpass filter of the
        previous version of the MNRU
  \item The need of an input speech DC-component removal filter
        was added to the specification.
\end{itemize}

These changes, especially the elimination of the 5:1 speech data rate
conversion, allowed for the implementation of both the narrowband and
the wideband MNRU within the same C function, when the output filter is
adequately designed \cite[pp.7--12]{Duo-MNRU}.

The random number generator (RNG) algorithm was also modified to allow
for real-time implementations, and the solution adopted was based on
Aachen University's approach used by the Host Laboratory for the ITU-T
G.729 Selection Tests.

%------------------------------------------------------------------------
% Rev.P.81 MNRU, as implemented in the STL96
% The original .fig file has NOT been scaled
%  and the box y-length has been decreased by 1cm and the ps data
%  shifted down by ~1cm (-18 points)
%------------------------------------------------------------------------
\begin{figure}[ht]
  \begin{center}
    \includegraphics{p81-impl}
  \end{center}
   \caption{STL MNRU implementation.\label{STL96-MNRU}}
\end{figure}
%------------------ End of test of figure ----------------------------------

The block diagram of the MNRU implemented in the STL is in
figure \ref{STL96-MNRU}.

The MNRU works internally on a sample-by-sample basis but for ease of
interface with other speech coding functions, access to it is made on
a sample block basis. It should be noted however that the filters have
memory, as well as do the random number generator, hence state
variables are needed. These state variables have been arranged as
fields of a structure whose {\tt type} name is {\tt MNRU\_state}. The
fields of the structure are:
\begin{quote} \normalsize
 {\em seed}     \hfill \parbox{100mm}{\SF RNG's seed }\\
 {\em signal\_gain}     \hfill \parbox{100mm}{\SF Gain of the signal path }\\
 {\em noise\_gain}      \hfill \parbox{100mm}{\SF Gain of the noise path }\\
 {\em vet}      \hfill \parbox{100mm}{\SF Array for intermediate data }\\
 {\em last\_xk} \hfill \parbox[t]{100mm}{\SF $x(k-1)$ used as memory for
                            the DC-removal filter }\\
 {\em last\_yk}\hfill \parbox[t]{100mm}{\SF $\xi(k-1)$ (see figure
                            \ref{STL96-MNRU}), used as memory for the
                            DC-removal filter}\\
 {\em DLY[2][2]}      \hfill \parbox[t]{100mm}{\SF Memory of delayed
                            samples for two second-order stages (first
                            index) for first- and second-order delays
                            (second index)}\\
 {\em A[2][2]}  \hfill \parbox[t]{100mm}{\SF Numerator coefficients for
                            the stage indicated by the first index and
                            delay-order inidcated by the second index}\\
 {\em B[2][2]}  \hfill \parbox[t]{100mm}{\SF Denominator coefficients for
                            the stage indicated by the first index and
                            delay-order inidcated by the second index}\\
 {\em rnd\_state}  \hfill \parbox[t]{100mm}{\SF State structure for MNRU's
                            random number generator. Detailed
                            description is found in the section on the
                            random number generator.}\\
 {\em rnd\_mode}   \hfill \parbox[t]{100mm}{\SF Operational mode of the
                            random number generator}\\
 {\em clip}     \hfill \parbox[t]{100mm}{\SF Number of samples clipped in
                            the noise-insertion process}\\
\end{quote}

The values of the fields shall not be altered by the user.


%----------------------------------------------------------------------------
{\Large\bf Filters in the MNRU module \ruley{2em} }\\*[0.5em]

The composite frequency response of the narrowband and wideband MNRU
filters is shown in figure \ref{MNRU:both-filters}. Figure
\ref{MNRU:lp-filter} shows the contribution of the output low-pass
filter for (a) the narrowband, and (b) the wideband cases. Figure
\ref{MNRU:hp-filter} shows the effect of the input DC-removal filter
for (a) the narrowband and (b) the wideband operation modes of the
MNRU. Details on the design of the output low-pass filters are given
in \cite{Duo-MNRU}. The frequency responses have been obtained by
exciting the MNRU module with digital sinewaves and computing the
ratio of input and output signals, in dB.


%---------------------------------------------------------------------
% Frequency response of MNRU filters: Both filters convolved
%---------------------------------------------------------------------
%mnrufrnb.ps: narrowband, full-filter
%Box dimension: 12.06cm x 10.48cm
%mnrufrwb.ps: wideband, full-filter
%Box dimension: 12.06cm x 10.48cm
%---------------------------------------------------------------------
\begin{figure}[p]
  \begin{center}
    \includegraphics{mnrufrnb}
    \\
    (a) Narrowband Duo-MNRU

    \includegraphics{mnrufrwb}
    \\
    (b) Wideband Duo-MNRU
  \end{center}
  \caption{ Total frequency response of the Duo-MNRU filters.
            \label{MNRU:both-filters}
          }
\end{figure}
%----------------------------------------------------------------------

%----------------------------------------------------------------------
% Frequency response of MNRU filters: zoom of LP part
%----------------------------------------------------------------------
%mnrudcnb.ps: narrowband, DC-removal HP filter
%Box dimension: 12.06cm x 10.48cm
%mnrudcwb.ps: wideband, DC-removal HP filter
%Box dimension: 12.06cm x 10.48cm
%----------------------------------------------------------------------
\begin{figure}[p]
  \begin{center}
    \includegraphics{mnrudcnb}
    \\
    (a) Narrowband Duo-MNRU

    \includegraphics{mnrudcwb}
    \\
    (b) Wideband Duo-MNRU
  \end{center}
  \caption{ DC removal filter for the Duo-MNRU. \label{MNRU:hp-filter} }
\end{figure}
%-----------------------------------------------------------------------

%-----------------------------------------------------------------------
% Frequency response of MNRU filters: zoom of DC (HP) part
%-----------------------------------------------------------------------
%mnrulpnb.ps: narrowband, output LP filter
%Box dimension: 12.06cm x 10.48cm
%mnrulpwb.ps: wideband, output LP filter
%Box dimension: 12.06cm x 10.48cm
%-----------------------------------------------------------------------
\begin{figure}[hp]
  \begin{center}
    \includegraphics{mnrulpnb}
    \\
    (a) Narrowband Duo-MNRU

    \includegraphics{mnrulpwb}
    \\
    (b) Wideband Duo-MNRU
  \end{center}
  \caption{ Output low-pass filter for the Duo-MNRU. \label{MNRU:lp-filter} }
\end{figure}
%-----------------------------------------------------------------------


%---------------------------------------------------------------------
% Filter structure of the MNRU
% The original box y-length has been decreased by 1cm and the ps data
%  shifted down by ~0.5cm (-10 points)
%---------------------------------------------------------------------
\begin{figure}[htb]
  \begin{center}
    \includegraphics{mnru-iir}
  \end{center}
  \caption{MNRU Filters Structure.\label{MNRU-IIR}}
\end{figure}
%---------------------------------------------------------------------


The input DC-removal filter was implemented using a first-order IIR
pole-zero filter defined by
\[
    H_i(z) = { 1-z^{-1} \over \ 1 - \alpha z^{-1} \ }
\]
with $\alpha$=0.985. Its -3dB point is at 16 Hz for the narrowband
case and at 38 Hz for the wideband case.

The output low-pass filter was implemented using a second-order
cascade-form IIR filter with two-sections as illustrated in figure
\ref{MNRU-IIR} and defined by the equation:
\[
    H_i(z) = A \prod_{k=1}^{2}
                    { a_{0k}+a_{1k}z^{-1}+a_{2k}z^{-2} \over
                      \ 1+b_{1k}z^{-1}+b_{2k} z^{-2} \
                                }
\]

IIR filters were chosen because of their low computational
complexity when compared to FIR implementations, allowing for a more
efficient MNRU implementation.


%------------------------------------------------------------------------------
{\Large\bf Random Number Generator for the MNRU module \ruley{2em} }\\*[0.5em]

The random number generator (RNG) used in this implementation was
chosen using the following criteria:

\rulex{5mm}
\begin{minipage}{130mm}
 $\bullet$ \parbox[t]{120mm}{
               the desired value for Q, $Q_d$, and the measured Q,
               $Q_m$, should be very
               close for a wide range of Q, e.g., Q from 0 to 50 dB.
               \bigskip}

 $\bullet$ \parbox[t]{120mm}{
               it should show a good approximation of a gaussian
               distribution. This is needed because it is
               specified in P.810 and more importantly because uniform
               distributions do not allow good matching between the
               desired and measured values of Q. \bigskip}

 $\bullet$ \parbox[t]{120mm}{
               the algorithm needed to be portable (i.e., identical results
               are got in different platforms if the same seed is given).}\\
\end{minipage}

The RNG chosen to be used in the STL92 version of the MNRU was based
on Knuth's Subtractive Method \cite{Recipes},\cite[Parts
3.2--3.3]{Knuth}, which generates adequate random sequences but is
computationally intensive and was too complex to be implemented in a
real-time digital hardware MNRU.

The implementation used in the ITU-T G.729 8
kbit/s speech codec selection tests was based on a gaussian-noise
table lookup, in a manner similar to Malden Electronic's
MNRU implementation.\footnote{\SF Malden's MNRU uses a ROM table
derived from  a Gaussian distribution with 4096 samples uniformly
distributed throughout the table. An address in the table is
uniformly sampled four times and accumulated to form a gaussian noise
sample.} This approach is considerably less computationally intensive
than the STL92 approach, and was used to further reduce the
complexity of the MNRU implementation.

After several experiments \cite{Duo-MNRU}, a table with 8192 gaussian
samples was chosen to be used, which is randomly and uniformly
accessed 8 times (i.e., an eight-time sample accumulation) to be used
by the MNRU algorithm. The gaussian table itself is generated in
run-time (rather than being stored in the data memory of the source
or object code) using the Monte-Carlo substitution algorithm.
The Monte-Carlo algorithm uses a linear congruential generation (LCG)
algorithm defined by
\[
            I_{j} = 69069 I_{j-1} + 1 \pmod{2^{32}}
\]
which is converted to numbers in the range [0..1] using the upper 24
bits of the 32-bit unsigned long $I_j$. $I_0$ is a fixed seed equal to
314159265. This algorithm is used to generate the necessary initial random
samples for the substitution algorithm.

Once the table has been filled, during the normal operation of the
MNRU, eight successive samples are drawn (uniformily) from the table
using a different LCG algorithm
\[
            L_{j} = 253 L_{j-1} + 1 \pmod{2^{24}}
\]
of which the upper 13 bits are used to generate random numbers
uniformly distributed between 0 and 8191. $L_0$ is a fixed seed equal
to 12345. Both LCGs were implemented as in Aachen University's MNRU
implementation.

Since different ranges are necessary for table filling and for
gaussian sample generation, two different LCG random number generators
were used to avoid any additional calculations due to range convertion
and to reduce the software load.

Since the Monte-Carlo RNG is used only at startup time, it is not
necessary to keep any state variables for it. The sample-drawing RNG
however needs to keep stored the previously generated index, which is
stored in a structure of type {\tt RANDOM\_state}, whose only field
is (as defined in {\tt mnru.h})\footnote{\SF The use of a structure
instead of a single variable in the parent structure ({\tt
MNRU\_state}) allows for unimplemented features to be easily added in
a later version of the algorithm.}:
\begin{quote} \normalsize
 {\em gauss}    \hfill \parbox{100mm}{\SF Index for next random number;}\\
\end{quote}

The field in {\tt RANDOM\_state} should not be altered by the user in
any situation.

The operational modes are defined in {\tt mnru.h}:

\rulex{5mm} \parbox[t]{120mm}{\tt
\#define RANDOM\_RUN 0\\
\#define RANDOM\_RESET 1\\*[5mm]
}

The noise modulation routine is {\tt MNRU\_process}, which is described
next.

\subsection{{\tt MNRU\_process}}

{\bf Syntax: }

{\tt
\#include "mnru.h"\\
double *MNRU\_process (\ttpbox{110mm}{
            char {\em operation}, {\tt MNRU\_state} {\em *s}, float {\em *input},
            float {\em *output}, long {\em n}, long {\em seed},
            char {\em mode}, double {\em Q});
         }
}

{\bf Prototype: }    mnru.h

{\bf Description: }

Module for addition of modulated noise to a vector of {\it n} samples,
according to \textcolor{blue}{Recommendation ITU-T} P.810, for either the narrowband or
the wideband model. Depending on the {\it mode}, this function:

\rulex{5mm}
\begin{minipage}{130mm}
 $\bullet$ \parbox[t]{120mm}{
           adds modulated noise to the {\it input} buffer at a SNR level of
          {\it Q} dB, saving to {\it output} buffer
          ({\it mode}=={\tt MOD\_NOISE});\\}

 $\bullet$ \parbox[t]{120mm}{
          puts into {\it output} only the noise, without addition of the
          original signal ({\it mode}=={\tt NOISE\_ONLY});\\}

 $\bullet$ \parbox[t]{120mm}{
          produces in the {\it output} a filtered-only (no noise added)
          version of the `input' samples
          ({\it mode}=={\tt SIGNAL\_ONLY});\\}

\end{minipage}

The symbols {\tt MOD\_NOISE}, {\tt NOISE\_ONLY}, and {\tt SIGNAL\_ONLY}
are defined in {\tt mnru.h}.

Although the MNRU algorithm operates on a sample-by-sample basis,
{\tt MNRU\_process} handles the input data in blocks of {\it n}
samples, for better computational efficiency.

The implementation of the MNRU algorithm has three operational
states, called {\tt MNRU\_START}, {\tt MNRU\_CONTINUE} and {\tt
MNRU\_STOP}. With {\tt MNRU\_START}, the state variables are set, as
well as memory is allocated for the intermediate  data, and this
needs to be the first operation with the algorithm. Differently from
the speech voltmeter module, after the initialization of the state
variables, the normal calculations are carried out for the first
block of data. Once reset, the algorithm changes the operation state
to {\tt MNRU\_CONTINUE}, and the next calls to the MNRU algorithm
will skip the reset operation. With the last block, it is adivisable to
release the memory allocated to the intermediate data. This is
accomplished by calling {\tt MNRU\_process} with the operational
state set as {\tt MNRU\_STOP}. These three operational states are
defined in {\tt mnru.h} as follows:

\rulex{5mm} \parbox[t]{120mm}{\tt
\#define MNRU\_START     1\\
\#define MNRU\_CONTINUE  0\\
\#define MNRU\_STOP     -1\\*[5mm]
}


{\bf Variables: }
\begin{Descr}{\DescrLen}
\item[\pbox{20mm}{\em operation}] %\rulex{1mm}\\
        One of the defined operation status:
        {\tt MNRU\_START}, {\tt MNRU\_STOP}, {\tt MNRU\_CONTINUE}.

\item[\pbox{20mm}{\em s}] %\rulex{1mm}\\
        A pointer to a {\tt MNRU\_state} structure.

\item[\pbox{20mm}{\em input}] %\rulex{1mm}\\
        Pointer to input float-data vector; must represent
                      8 or 16 kHz speech samples.

\item[\pbox{20mm}{\em output}] %\rulex{1mm}\\
        Pointer to output float-data vector; will represent
                      8 or 16 kHz speech samples.

\item[\pbox{20mm}{\em n}] %\rulex{1mm}\\
        Long with the number of samples (\float) in input.

\item[\pbox{20mm}{\em seed}] %\rulex{1mm}\\
        Initial value for random number generator.

\item[\pbox{20mm}{\em mode}] %\rulex{1mm}\\
        Operation mode: {\tt MOD\_NOISE}, {\tt SIGNAL\_ONLY},
        {\tt NOISE\_ONLY} (description above).

\item[\pbox{20mm}{\em Q}] %\rulex{1mm}\\
        Double defining the desired value for the
        signal-to-modulated-noise $Q$ for the output data.
\end{Descr}

Please note that new values of {\em seed}, {\em mode}, and $Q$ are
considered only when {\em operation} is {\tt MNRU\_START}, because they are
considered as INITIAL state values. Therefore, when the operation is
not {\tt MNRU\_START}, they are ignored.


{\bf Return value: }

Returns a {\tt (double *)NULL} if not initialized or if initialization
failed; returns a {\tt (double *)} to an intermediate data vector if reset
was successful or is in the {\tt MNRU\_CONTINUE} (``run'') operation
state.


\section{Portability and compliance} \label{MNRU-Tests}

In the development of this module, several steps were taken to assure
its compliance to \textcolor{blue}{Recommendation ITU-T} P.810, which included:

\begin{itemize}
  \item agreement of expected and measured Q values for tones and
        speech,
  \item addition of partial files,
  \item level of output files,
  \item frequency response of built-in filters.
\end{itemize}

Additionally to these objective measurements, a subjective test was
performed. The results of this test are found in \cite{Duo-MNRU},
where it was concluded that the new MNRU implementation conforms to
the P.810 and also behaves more closely to the hardware MNRU
than the previous STL92 version.

Additionally to the conformance tests, the algorithm was tested for
portability using a 1kHz tone file as input to the algorithm with Q
values ranging from 0 to 50 dB in 5 dB steps, and also for the
algorithm in the {\tt SIGNAL\_ONLY} mode. The processed test files were
then compared the the reference processed files (generated on a HP
workstation). Test and reference files should be identical.
The algorithm was found to compile and execute correctly on MS-DOS
under Borland Turbo-C++ 1.0 and under the MS-DOS port of the GNU-C
compiler (gcc), on a HP UNIX workstation with cc (non-ANSI) and gcc,
on a Sun workstation with cc (non-ANSI) and also on VAX VMS and APX
computers.


%-----------------------------------------------------------------
\section{Example code}

%.....................................................................
\subsection {Description of the demonstration programs}

One demonstration program is provided for the MNRU module, mnrudemo.c.
Irrespective of whether the 16-bit, linear PCM input file is sampled
at 8 or 16 kHz, program {\tt mnrudemo.c} will add the multiplicative
noise signal to the input signal at the user-defined $Q$ level and
produce as output a 16-bit, linear PCM file. Optionally, the program
can produce a signal-only file (equivalent to a very high Q value) or
a noise-only file (the signal path is disconnected).

%These three modes of operation are provided for compatibility with the
%``classical'' hardware MNRU implementation.

%..........................................................................
\subsection {Simple example}

The following C code gives an example of a possible use of the Duo-MNRU module.
The input file speech is added to a multiplicative noise at a SNR defined by
parameter Q. All samples in the file are processed.

{\tt\small
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "ugstdemo.h"
#include "mnru.c"               /* ... Include MNRU module ... */
#include "ugst-utl.c"           /* ... Include of utilities ... */

#define BLK_LEN 256
main(argc, argv)
  int             argc;
  char           *argv[];
{
  /* File variables */
  char            FileIn[80], FileOut[80];
  FILE           *Fi, *Fo;
  MNRU_state      state;
  short           Buf[BLK_LEN];
  float           inp[BLK_LEN], out[BLK_LEN];
  double          QdB;
  long            l;
  char            MNRU_mode = MOD_NOISE, operation;

  /* Read parameters for processing */
  GET_PAR_S(1, "_Input File: ................. ", FileIn);
  GET_PAR_S(2, "_Output File: ................ ", FileOut);
  GET_PAR_D(3, "_Desired Q: .................. ", QdB);

  /* Check for parameter 4 to change MNRU operation mode */
  if (argc > 4)
  {
    MNRU_mode = toupper(argv[5][0]);
    if (MNRU_mode == 'S')       /* Signal-only mode */
      MNRU_mode = SIGNAL_ONLY;
    else if (MNRU_mode == 'M')  /* Modulated noise, the default mode */
      MNRU_mode = MOD_NOISE;
    else if (MNRU_mode == 'N')  /* Noise-only mode */
      MNRU_mode = NOISE_ONLY;
    else
    {
      fprintf(stderr, "Bad mode chosen; use M,N,or S \n"); exit(2);
    }
  }

  /* Opening input and output files */
  Fi = fopen(FileIn, RB);
  Fo = fopen(FileOut, WB);

  /* INSERTION OF MODULATED NOISE ACCORDING TO P.810 (FEB.96) */

  /* Set operation as start */
  operation = MNRU_START;

  /* Process for all samples in file */
  while ((l = fread(Buf, sizeof(short), BLK_LEN, Fi)) != NULL)
  {
    /* Convert data from 16-bit short to normalized float */
    sh2fl_16bit((long) l, Buf, inp, 1);

    /* MNRU processing */
    MNRU_process(operation, &state, inp, out, l, 314159265L, MNRU_mode, QdB);

    /* Change operation mode: START --> CONTINUE */
    if (operation == MNRU_START)
      operation = MNRU_CONTINUE;

    /* Convert from normalized float to short (hard clip and rounding) */
    fl2sh_16bit((long) l, out, Buf, 1);

    /* Save data to file */
    fwrite(Buf, sizeof(short), l, Fo);
  }

  /* Stop mode: Deallocation of memory, but process 0 samples */
  operation = MNRU_STOP;
  MNRU_process (operation, &state, inp, out, 0L, 0L, 0, (double) 0.0);

  /* Finalizations */
  fclose(Fi);
  fclose(Fo);
  return(0);
}
\end{verbatim}
}
