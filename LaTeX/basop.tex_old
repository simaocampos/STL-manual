%=============================================================================
% ..... THIS IS chapter{BASOP: ITU-T Basic Operators } .....
% ... Revision:
% Nov.2000 - SG16 Plenary
% Apr.2005 - STL2005 revision -- Cyril Guillaumé & Stéphane Ragot - stephane.ragot@francetelecom.com
%                                Karim Djafarian - k-djafarian@ti.com
%=============================================================================
\chapter{BASOP: ITU-T Basic Operators}
%=============================================================================

%\newcommand{\newop}{\ensuremath{\Rightarrow} \textsc{New in v2.0}}
\def\newop{\begin{math} \rightarrow \textsc{New in v2.0} \end{math}}

%----------------------------------------------------------------------
\section{Overview of basic operator libraries}
%----------------------------------------------------------------------

The fixed-point descriptions of G.723.1 and G.729 are based on 16- and
32-bit arithmetic operations defined by ETSI in 1993 for the
standardisation of the half-rate GSM speech codec. These operations
are also used to define the GSM enhanced full-rate (EFR) and adaptive
multi-rate (AMR) speech codecs \cite{G.191}.

The version 2.0 of the ITU-T Basic Operators bears the following
additional features compared to the version 1.x:
\begin{enumerate}
\item New 16-bit and 32-bit operators;
\item New 40-bit operators;
\item New control flow operators; 
\item Revised complexity weight of version 1.x basic operators in order to reflect the evolution of processor capabilities.
\end{enumerate}

%----------------------------------------------------------------------
\section{Description of the 16-bit and 32-bit basic operators and 
associated weights}
%----------------------------------------------------------------------

This chapter describes the different 16-bit and 32-bit basic
operators available in the STL, and are organized by complexity
("weights"). The complexity values to be considered (as of the
publication of the STL2005) are the ones related to the version
2.0 of the module. When the basic operator had a different
complexity value in the previous version of the library (version
1.x), the previous complexity value is indicated for information.
When the basic operator did not exist in the previous version of
the library (version 1.x), it is highlighted as follows: \newop .

\subsection{Variable definitions}

The variables used in the operators are signed integers in 2's
complements representation, defined by:

{\tt v1}, {\tt v2}: 16-bit variables\\
{\tt L\_v1}, {\tt L\_v2}, {\tt L\_v3}: 32-bit variables



%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 1}
\subsubsection{Arithmetic operators (multiplication excluded)}

%........................................................
\NewOperator{add(v1, v2)}

Performs the addition ({\tt v1}+{\tt v2}) with overflow control and
saturation; the 16-bit result is set at {\tt +32767} when overflow
occurs or at {\tt -32768} when underflow occurs.

%........................................................
\NewOperator{sub(v1, v2)}

Performs the subtraction ({\tt v1}-{\tt v2}) with overflow control and
saturation; the 16-bit result is set at {\tt +32767} when overflow
occurs or at {\tt -32768} when underflow occurs.

%........................................................
\NewOperator{abs\_s(v1)}

Absolute value of v1. If {\tt v1} is {\tt -32768}, returns {\tt 32767}.

%........................................................
\NewOperator{shl(v1, v2)}

Arithmetically shift the 16-bit input {\tt v1} left {\tt v2}
positions. Zero fill the {\tt v2} LSB of the result. If {\tt v2} is
negative, arithmetically shift {\tt v1} right by {\tt -v2} with sign
extension. Saturate the result in case of underflows or overflows.

%........................................................
\NewOperator{shr(v1, v2)}

Arithmetically shift the 16-bit input {\tt v1} right {\tt v2}
positions with sign extension. If v2 is negative, arithemtically shift
{\tt v1} left by {\tt -v2} and zero fill the {\tt -v2} LSB of the
result:

\rulex{2mm}{\tt shr(v1, v2) = shl(v1, -v2)}

Saturate the result in case of underflows or overflows.

%........................................................
\NewOperator{negate(v1)}

Negate {\tt v1} with saturation, saturate in the case when input
is {\tt -32768}:

\rulex{2mm}{\tt negate(v1) = sub(0, v1)}

%........................................................
\NewOperator{s\_max(v1, v2)} \newop

Compares two 16-bit variables {\tt v1} and {\tt v2} and returns
the maximum value. 

%........................................................
\NewOperator{s\_min(v1, v2)} \newop

Compares two 16-bit variables {\tt v1} and {\tt v2} and returns
the minimum value. 

%........................................................
\NewOperator{norm\_s(v1)}

Produces the number of left shifts needed to normalize the 16-bit
variable {\tt v1} for positive values on the interval with minimum
of {\tt 16384} and maximum {\tt 32767}, and for negative values on
the interval with minimum of {\tt -32768} and maximum of {\tt
-16384}; in order to normalise the result, the following operation
must be done:

\rulex{2mm}{\tt norm\_v1 = shl(v1, norm\_s(v1))}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was 15.}

%........................................................
\NewOperator{L\_add(L\_v1, L\_v2)}

This operator implements 32-bit addition of the two 32-bit
variables ({\tt L\_v1}+{\tt L\_v2}) with overflow control and
saturation; the result is set at {\tt +2147483647} when overflow
occurs or at {\tt -2147483648} when underflow occurs.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_sub(L\_v1, L\_v2)}

32-bit subtraction of the two 32-bit variables ({\tt L\_v1}--{\tt
L\_v2}) with overflow control and saturation; the result is set at
{\tt +2147483647} when overflow occurs or at {\tt -2147483648}
when underflow occurs.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_abs(L\_v1)}

Absolute value of {\tt L\_v1}, with {\tt
L\_abs(-2147483648)=\-2147483647}.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_shl(L\_v1, v2)}

Arithmetically shift the 32-bit input {\tt L\_v1} left {\tt v2}
positions. Zero fill the {\tt v2} LSB of the result. If {\tt v2}
is negative, arithmetically shift {\tt L\_v1} right by {\tt -v2}
with sign extension. Saturate the result in case of underflows or
overflows.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_shr(L\_v1, v2)}

Arithmetically shift the 32-bit input {\tt L\_v1} right {\tt v2}
positions with sign extension. If {\tt v2} is negative,
arithemtically shift {\tt L\_v1} left by {\tt -v2} and zero fill
the {\tt -v2} LSB of the result. Saturate the result in case of
underflows or overflows.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_negate(L\_v1)}

Negate the 32-bit {\tt L\_v1} parameter with saturation, saturate in the
case where input is {\tt -2147483648}.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_max(L\_v1, L\_v2)} \newop

Compares two 32-bit variables L\_v1 and L\_v2 and returns the
maximum value. 

%........................................................
\NewOperator{L\_min(L\_v1, L\_v2)} \newop

Compares two 32-bit variables L\_v1 and L\_v2 and returns the
minimum value.

%........................................................
\NewOperator{norm\_l(L\_v1)}

Produces the number of left shifts needed to normalise the 32-bit
variable {\tt L\_v1} for positive values on the interval with
minimum of {\tt 1073741824} and maximum {\tt 2147483647}, and for
negative values on the interval with minimum of {\tt -2147483648}
and maximum of {\tt -1073741824}; in order to normalise the
result, the following operation must be done:

\rulex{2mm}{\tt L\_norm\_v1 = L\_shl(L\_v1, norm\_l(L\_v1))}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  30.}

%------------------------------------------------------------------
\subsubsection{Multiplication operators}

%........................................................
\NewOperator{L\_mult(v1, v2)}

Operator {\tt L\_mult} implements the 32-bit result of the
multiplication of {\tt v1} times {\tt v2} with one shift left,
i.e.

\rulex{2mm}{\tt L\_mult(v1, v2) = L\_shl((v1 $\times$ v2), 1)}

Note that {\tt L\_mult(-32768,-32768) = 2147483647}.

%........................................................
\NewOperator{L\_mult0(v1, v2)}

Operator {\tt L\_mult0} implements the 32-bit result of the
multiplication of {\tt v1} times {\tt v2} {\em without} left
shift, i.e.

\rulex{2mm}{\tt L\_mult0(v1, v2) = (v1 $\times$ v2)}

%........................................................
\NewOperator{mult(v1, v2)}

Performs the multiplication of {\tt v1} by {\tt v2} and gives a 16-bit
result which is scaled, i.e.

\rulex{2mm}{\tt mult(v1, v2) =  extract\_l(L\_shr((v1 times v2),15))}

Note that {\tt mult(-32768,-32768) = 32767}.

%........................................................
\NewOperator{mult\_r(v1, v2)}

Same as {\tt mult()} but with rounding, i.e.

\rulex{2mm}{\tt mult\_r(v1, v2)
                = extract\_l(L\_shr(((v1 $\times$ v2)+16384), 15))}

and {\tt mult\_r(-32768, -32768) = 32767}.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_mac(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Add the
32-bit result to {\tt L\_v3} with saturation, return a 32-bit result:

\rulex{2mm}{\tt L\_mac(L\_v3, v1, v2) = L\_add(L\_v3, L\_mult(v1, v2))}

%........................................................
\NewOperator{L\_mac0(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} {\em without} left shift. Add the 32-bit
result to {\tt L\_v3} with saturation, returning a 32-bit result:

\rulex{2mm}{\tt L\_mac0(L\_v3, v1, v2) = L\_add(L\_v3, L\_mult0(v1,
v2))}

%........................................................
\NewOperator{L\_macNs(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Add the
32-bit result to {\tt L\_v3} without saturation, return a 32-bit
result. Generates carry and overflow values:

\rulex{2mm}{\tt L\_macNs(L\_v3, v1, v2) = L\_add\_c(L\_v3,
L\_mult(v1, v2))}

%........................................................
\NewOperator{mac\_r(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Add
the 32-bit result to {\tt L\_v3} with saturation. Round the 16
least significant bits of the result into the 16 most significant
bits with saturation and shift the result right by 16. Returns a
16-bit result.

\rulex{2mm}{\tt mac\_r(L\_v3, v1, v2) = \\
  \rulex{5mm} round(L\_mac(L\_v3, v1, v2))=\\
  \rulex{5mm} extract\_h(L\_add(L\_add(L\_v3, L\_mult(v1, v2)), 32768))}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_msu(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Subtract
the 32-bit result from {\tt L\_v3} with saturation, return a 32-bit
result:

\rulex{2mm}{\tt L\_msu(L\_v3, v1, v2) = L\_sub(L\_v3, L\_mult(v1, v2))}.

%........................................................
\NewOperator{L\_msu0(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} {\em without} left shift. Subtract the
32-bit result from {\tt L\_v3} with saturation, returning a 32-bit
result:

\rulex{2mm}{\tt L\_msu0(L\_v3, v1, v2) = L\_sub(L\_v3, L\_mult0(v1,
v2))}.

%........................................................
\NewOperator{L\_msuNs(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1. Subtract
the 32-bit result from {\tt L\_v3} without saturation, return a 32-bit
result. Generates carry and overflow values:


\rulex{2mm}{\tt L\_msuNs(L\_v3, v1, v2) = L\_sub\_c(L\_v3, L\_mult(v1, v2))}

%........................................................
\NewOperator{msu\_r(L\_v3, v1, v2)}

Multiply {\tt v1} by {\tt v2} and shift the result left by 1.
Subtract the 32-bit result from {\tt L\_v3} with saturation. Round
the 16 least significant bits of the result into the 16 bits with
saturation and shift the result right by 16. Returns a 16-bit
result.

\ \\
\rulex{2mm}{\tt msu\_r(L\_v3, v1, v2) = \\
   \rulex{5mm} round(L\_msu(L\_v3, v1, v2))= \\
   \rulex{5mm} extract\_h(L\_add(L\_sub(L\_v3, L\_mult(v1, v2)), 32768))}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

\subsubsection{Logical operators}

%........................................................
\NewOperator{s\_and(v1, v2)} \newop

Performs a bit wise AND between the two 16-bit variables v1 and
v2.

%........................................................
\NewOperator{s\_or(v1, v2)} \newop

Performs a bit wise OR between the two 16-bit variables v1 and
v2. 

%........................................................
\NewOperator{s\_xor(v1, v2)} \newop

Performs a bit wise XOR between the two 16-bit variables v1 and
v2. 

%........................................................
\NewOperator{lshl(v1, v2)} \newop

Logically shifts left the 16-bit variable v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, v1 is shifted to the least
significant bits by (-v2) positions with insertion of 0 at the
most significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, v1 is shifted to the most
significant bits by (v2) positions without saturation control.}



%........................................................
\NewOperator{lshr(v1, v2)} \newop

Logically shifts right the 16-bit variable v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, v1 is shifted to the least
significant bits by (v2) positions with insertion of 0 at the most
significant bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, v1 is shifted to the most
significant bits by (-v2) positions without saturation control.}


%........................................................
\NewOperator{L\_and(L\_v1, L\_v2)} \newop

Performs a bit wise AND between the two 32-bit variables {\tt
L\_v1} and {\tt L\_v2}.


%........................................................
\NewOperator{L\_or(L\_v1, L\_v2)} \newop

Performs a bit wise OR between the two 32-bit variables {\tt
L\_v1} and {\tt L\_v2}.


%........................................................
\NewOperator{L\_xor(L\_v1, L\_v2)} \newop

Performs a bit wise XOR between the two 32-bit variables {\tt
L\_v1} and {\tt L\_v2}.


%........................................................
\NewOperator{L\_lshl(L\_v1, v2)} \newop

Logically shifts left the 32-bit variable {\tt L\_v1} by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, {\tt L\_v1} is shifted
to the least significant bits by (-v2) positions with insertion of 0
at the most significant bit.} 

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, {\tt L\_v1} is shifted
to the most significant bits by (v2) positions without saturation
control.} 


%........................................................
\NewOperator{L\_lshr(L\_v1, v2)} \newop

Logically shifts right the 32-bit variable {\tt L\_v1} by v2
positions: 

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, {\tt L\_v1} is shifted
to the least significant bits by (v2) positions with insertion of 0 at
the most significant bit.} 

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, {\tt L\_v1} is shifted
to the most significant bits by (-v2) positions without saturation
control.} 


\subsubsection{Data type conversion operators}

%........................................................
\NewOperator{extract\_h(L\_v1)}

Return the 16 MSB of {\tt L\_v1}.

%........................................................
\NewOperator{extract\_l(L\_v1)}

Return the 16 LSB of {\tt L\_v1}.

%........................................................
\NewOperator{round(L\_v1)} 

Round the lower 16 bits of the 32-bit input number into the most
significant 16 bits with saturation. Shift the resulting bits
right by 16 and return the 16-bit number:

\rulex{2mm}{\tt round(L\_v1) = extract\_h(L\_add(L\_v1, 32768))}

%........................................................
\NewOperator{L\_deposit\_h(v1)}

Deposit the 16-bit {\tt v1} into the 16 most significant bits
of the 32-bit output. The 16 least significant bits of the output
are zeroed.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

%........................................................
\NewOperator{L\_deposit\_l(v1)}

Deposit the 16-bit {\tt v1} into the 16 least significant bits
of the 32-bit output. The 16 most significant bits of the output
are sign-extended.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  2.}

\subsection{Operators with complexity weight of 2}

%........................................................
\NewOperator{L\_add\_c(L\_v1, L\_v2)}

Performs the 32-bit addition with carry. No saturation. Generates
carry and overflow values. The carry and overflow values are
binary variables which can be tested and assigned values.

%........................................................
\ \\
\NewOperator{L\_sub\_c(L\_v1, L\_v2)}

Performs the 32-bit subtraction with carry (borrow). Generates
carry (borrow) and overflow values. No saturation. The carry and
overflow values are binary variables which can be tested and
assigned values.

\subsection{Operators with complexity weight of 3}
\subsubsection{Arithmetic operators}

%........................................................
\NewOperator{shr\_r(v1, v2)}

Same as {\tt shr()} but with rounding. Saturate the result in case
of underflows or overflows.

{\tt
\rulex{2mm} if (v2$>$0) then\\
   \rulex{4mm} if (sub(shl(shr(v1,v2),1), shr(v1,sub(v2,1)))==0) \\
   \rulex{4mm} then shr\_r(v1, v2) = shr(v1, v2)\\
   \rulex{4mm} else shr\_r(v1, v2) = add(shr(v1, v2), 1)

\rulex{2mm} else if (v2 $\leq$ 0) \\
   \rulex{4mm} then shr\_r(v1, v2) = shr(v1, v2)}

%........................................................
\NewOperator{shl\_r(v1, v2)}

Same as {\tt shl()} but with rounding. Saturate the result in case
of underflows or overflows:

\rulex{2mm}{\tt shl\_r(v1, v2) = shr\_r(v1, -v2)}

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of
this operator was  2. Additionally, please note that in v1.x this
operator was called \textbf{shift\_r(v1, v2)}; in the STL2005, both
names can be used.}

%........................................................
\NewOperator{L\_shr\_r(L\_v1, v2)}


Same as {\tt L\_shr(v1,v2)} but with rounding. Saturate the result
in case of underflows or overflows:

{\tt
\rulex{2mm} if (v2 $>$ 0) then\\
  \rulex{4mm} if (L\_sub(L\_shl(L\_shr(L\_v1,v2),1), L\_shr(L\_v1, sub(v2,1)))) == 0 \\
  \rulex{4mm} then L\_shr\_r(L\_v1, v2) = L\_shr(L\_v1, v2)\\
  \rulex{4mm} else L\_shr\_r(L\_v1, v2) = L\_add(L\_shr(L\_v1, v2), 1)

\rulex{2mm} if (v2 $\leq$ 0) \\
  \rulex{4mm} then L\_shr\_r(L\_v1, v2) = L\_shr(L\_v1, v2)}

%........................................................
\NewOperator{L\_shl\_r(L\_v1, v2)}

Same as {\tt L\_shl(L\_v1,v2)} but with rounding. Saturate the
result in case of underflows or overflows.

\rulex{2mm}{\tt L\_shl\_r(L\_v1, v2) = L\_shr\_r(L\_v1, -v2)}

In v1.x, this operator is called \textbf{L\_shift\_r(L\_v1, v2}) ;
both names can be used.

%........................................................
\NewOperator{i\_mult(v1, v2)}

Multiply two 16-bit words {\tt v1} and {\tt v2} returning a 16-bit
word with overflow control.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of 
this operator was  1. \textcolor{red}{The complexity update to the 
weight of 3 was motivated by the fact that the primitive is performing 
something equivalent to extract\_h( L\_shl( L\_mult0( v1, v2), 16))} }

\subsubsection{Logical Operators}

%........................................................
\NewOperator{rotl(v1, v2, * v3)} \newop

Rotates the 16-bit variable v1 by 1 bit to the most significant
bits. Bit 0 of v2 is copied to the least significant bit of the
result before it is returned. The most significant bit of v1 is
copied to the bit 0 of v3 variable.

%........................................................
\NewOperator{rotr(v1, v2, * v3)} \newop

Rotates the 16-bit variable v1 by 1 bit to the least significant
bits. Bit 0 of v2 is copied to the most significant bit of the
result before it is returned. The least significant bit of v1 is
copied to the bit 0 of v3 variable.


%........................................................
\NewOperator{L\_rotl(L\_v1, v2, * v3)} \newop

Rotates the 32-bit variable L\_v1 by 1 bit to the most significant
bits. Bit 0 of v2 is copied to the least significant bit of the
result before it is returned. The most significant bit of L\_v1 is
copied to the bit 0 of v3 variable.


%........................................................
\NewOperator{L\_rotr(L\_v1, v2, * v3)} \newop

Rotates the 32-bit variable L\_v1 by 1 bit to the least
significant bits. Bit 0 of v2 is copied to the most significant
bit of the result before it is returned. The least significant bit
of L\_v1 is copied to the bit 0 of v3 variable.


\subsection{Operators with complexity weight of 4}

%........................................................
\NewOperator{L\_sat(L\_v1)}

The 32-bit variable L\_v1 is set to {\tt 2147483647} if an overflow
occurred, or {\tt -2147483648} if an underflow occurred, on the
most recent {\tt L\_add\_c()}, {\tt L\_sub\_c()}, {\tt L\_macNs()}
or {\tt L\_msuNs()} operations. The carry and overflow values are
binary variables which can be tested and assigned values.

\enlargethispage*{10mm}

\subsection{Operators with complexity weight of 5}

%........................................................
\NewOperator{L\_mls(L\_v1, v2)}

Performs a multiplication of a 32-bit variable {\tt L\_v1} by a 16-bit
variable {\tt v2}, returning a 32-bit value.

\textbf{Note:} \hfill \pbox{145mm}{In v1.x, the complexity weight of this operator was  6.}

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 18}


%........................................................
\NewOperator{div\_s(v1, v2)}

Produces a result which is the fractional integer division of {\tt
v1} by {\tt v2}. Values in {\tt v1} and {\tt v2} must be positive
and {\tt v2} must be greater than or equal to {\tt v1}. The result
is positive (leading bit equal to 0) and truncated to 16 bits. If
{\tt v1}={\tt v2}, then {\tt div(v1, v2) = 32767}.

\subsection{Operators with complexity weight of 32}

%........................................................
\NewOperator{div\_l(L\_v1, v2)} %\rulex{1mm}

Produces a result which is the fractional integer division of a
positive 32-bit value {\tt L\_v1} by a positive 16-bit value {\tt
v2}. The result is positive (leading bit equal to 0) and truncated
to 16 bits.

%--------------------------------------------------
\subsection{Basic operator usage across standards}
%--------------------------------------------------

Table \ref{tbl:basop-in-recs} contains a survey of the 16-bit and
32-bit basic operators which are used in various standards.
Follows some notes associated to \ref{tbl:basop-in-recs}:

\begin{enumerate}
\item abs\_s(v1) is referred to as abs(v1) in GSM 06.10 (GSM full-rate). 
\item shl(v1,v2) is written as v1$<<$v2 in GSM 06.10. 
\item shr(v1,v2) is written as v1$>>$v2 in GSM 06.10.
\item v2=extract\_h(L\_v1) is written as v2 = L\_v1 in GSM 06.10. 
\item negate(v1) is written as --v1 in GSM 06.10. 
\item L\_negate(L\_v1) is written as --L\_v1 in GSM 06.10. 
\item L\_shl(L\_v1,v2) is written as L\_v1$<<$v2 in GSM 06.10. 
\item L\_shr(L\_v1,v2) is written as L\_v1$>>$v2 in GSM 06.10. 
\item L\_v2=deposit\_l(v1) is written as L\_v2=v1 in GSM 06.10. 
\item div\_s(v1,v2) is written as div(v1,v2) in GSM 06.10. 
\item norm\_l(L\_v1) is written as norm(L\_v1) in GSM 06.10. 
\item GSM 06.20 uses shift\_r(v1,v2), which can be implemented 
        as shr\_r(v1,--v2).
\item GSM 06.20 uses L\_shift\_r(L\_v1,v2), which can be
        implemented as L\_shr\_r(L\_v1,--v2).
\item div\_s(v1,v2) is written as divide\_s(v1,v2) in GSM 06.20.
\item Operator is not part of the original ETSI library. 
\item Operator is not part of the original ETSI library but was
        accepted in the TETRA standard.
\end{enumerate}


%-----------------------------------------------------------------
% Table with Basic operators in ITU Recs
%-----------------------------------------------------------------
\begin{table}[th]
\Caption{14cm}{\SF Use of 32-bit basic operators in G.723.1, G.729
             and ETSI GSM speech coding recommendations.
             \label{tbl:basop-in-recs}}
\begin{center}
\footnotesize
\begin{tabular}{|l|c|c|c|c|c|c|c|c|}
\hline
Operation &Weight &FR GSM &HR GSM &EFR GSM &AMR GSM &G.729 &G.723.1 &TETRA\\
\hline \hline
{\tt add()}     &1 &X &X &X &X &X &X &X\\
{\tt sub()}     &1 &X &X &X &X &X &X &X\\
{\tt abs\_s()}  &1 &X (1) &X &X &X &X &X &X\\
{\tt shl()}     &1 &X (2) &X &X &X &X &X &X\\
{\tt shr()}     &1 &X (3) &X &X &X &X &X &X\\
{\tt extract\_h()}      &1 & &X &X &X &X &X &X\\
{\tt extract\_l()}      &1 &X (4) &X &X &X &X &X &X\\
{\tt mult()}    &1 &X &X &X &X &X &X &X\\
{\tt L\_mult()} &1 &X &X &X &X &X &X &X\\
{\tt negate()}  &1 &X (5) &X &X &X &X &X & \\
{\tt round()}   &1 & &X &X &X &X &X &X\\
{\tt L\_mac()}  &1 & &X &X &X &X &X &X\\
{\tt L\_msu()}  &1 & &X &X &X &X &X &X\\
{\tt L\_macNs()}        &1 & & &X & &X &X & \\
{\tt L\_msuNs()}        &1 & & & & &X &X & \\
{\tt L\_add()}  &1 &X &X &X &X &X &X &X\\
{\tt L\_sub()}  &1 &X &X &X &X &X &X &X\\
{\tt L\_negate()}       &1 &X (6) &X &X &X &X &X &X\\
{\tt L\_shl()}  &1 &X (7) &X &X &X &X &X &X\\
{\tt L\_shr()}  &1 &X (8) &X &X &X &X &X &X\\
{\tt mult\_r()} &1 &X &X &X &X &X &X &X\\
{\tt mac\_r()}  &1 & &X & & & &X & \\
{\tt msu\_r()}  &1 & &X & & & &X & \\
{\tt L\_deposit\_h()}   &1 & &X &X &X &X &X &X\\
{\tt L\_deposit\_l()}   &1 &X (9) &X &X &X &X &X &X\\
{\tt L\_abs()}  &1 & &X &X &X &X &X &X\\
{\tt norm\_s()}         &1 & &X &X &X &X &X & \\
{\tt norm\_l()} &1 &X (11) &X &X &X &X &X &X\\
{\tt L\_add\_c()}       &2 & & & & & &X & \\
{\tt L\_sub\_c()}       &2 & & & & & &X & \\
{\tt shr\_r()}  &3 & &X (12) &X &X &X &X & \\
{\tt L\_shr\_r()}       &3 & &X (13) &X &X &X &X &X\\
{\tt L\_sat()}  &4 & & & & &X &X &\\
{\tt div\_s()}  &18 &X (10) &X (14) &X &X &X &X &X\\
\hline
{\tt i\_mult()} &3 & & & & & &X (15) & \\
{\tt L\_mls()}  &5 & & & & & &X (15) & \\
{\tt div\_l()}  &32 & & & & & &X (15) & \\
\hline
{\tt L\_mult0()} &1 & & & & & & &X (16)\\
{\tt L\_mac0()}  &1 & & & & & & &X (16)\\
{\tt L\_msu0()}  &1 & & & & & & &X (16)\\
\hline
\end{tabular}
\end{center}
\end{table}

%-----------------------------------------------------------------
\flushfloats

%----------------------------------------------------------------------
\section{Description of the 40-bit basic operators and associated weights}
%----------------------------------------------------------------------

This section describes the different 40-bit basic operators
available in the STL, and are organized by complexity ("weights").
The complexity values to be considered (as of the publication of
the STL2005) are the ones related to the version 2.0 of the
library. These basic operators did not exist in the previous
version of the library (version 1.x).

A set of coding guidelines must be followed in order to avoid
algorithm complexity miss-evaluation. This chapter describes also
these guidelines.

\subsection{Variable definitions}

The variables used in the operators are signed integers in 2's
complements representation, defined by:

{\tt v1}, {\tt v2}: 16-bit variables\\
{\tt L\_v1}, {\tt L\_v2}, {\tt L\_v3}: 32-bit variables\\
{\tt L40\_v1}, {\tt L40\_v2}, {\tt L40\_v3}: 40-bit variables\\

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\subsection{Operators with complexity weight of 1}
\subsubsection{Arithmetic operators (multiplication excluded)}

%........................................................
\NewOperator{L40\_add(L40\_v1, L40\_v2)}

Adds the two 40-bit variables L40\_v1 and L40\_v2 \textbf{without}
40-bit saturation control. It will exit execution if it detects a 40-bit overflow.


%........................................................
\NewOperator{L40\_sub(L40\_v1, L40\_v2)}

Subtracts the two 40-bit variables L40\_v2 from L40\_v1
\textbf{without} 40-bit saturation control. 
It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_abs(L40\_v1)}

Returns the absolute value of the 40-bit variable L40\_v1 without
40-bit saturation control. 
It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_shl(L40\_v1, v2)}

Arithmetically shifts left the 40-bit variable L40\_v1 by v2
positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to the least
significant bits by (-v2) positions with extension of the sign bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to the most
significant bits by (v2) positions \textbf{without} 40-bit saturation
control. It will exit execution if it detects a 40-bit overflow.}

%........................................................
\NewOperator{L40\_shr(L40\_v1, v2)}

Arithmetically shifts right the 40-bit variable L40\_v1 by v2
positions: 

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to the least
significant bits by (v2) positions with extension of the sign bit.}

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to the most
significant bits by (-v2) positions \textbf{without} 40-bit saturation
control. It will exit execution if it detects a 40-bit overflow.}

%........................................................
\NewOperator{L40\_negate(L40\_v1)}

Negates the 40-bit variable L40\_v1 \textbf{without} 40-bit saturation
control. It will exit execution if it detects a 40-bit overflow.

%........................................................
\NewOperator{L40\_max(L40\_v1, L40\_v2)}

Compares two 40-bit variables L40\_v1 and L40\_v2 and returns the
maximum value.

%........................................................
\NewOperator{L40\_min(L40\_v1, L40\_v2)}

Compares two 40-bit variables L40\_v1 and L40\_v2 and returns the
minimum value.

%........................................................
\NewOperator{norm\_L40(L40\_v1)}

Produces the number of left shifts needed to normalize the 40-bit
variable L40\_v1 for positive values on the interval with minimum
of 1073741824 and maximum 2147483647, and for negative values on
the interval with minimum of -2147483648 and maximum of
-1073741824; in order to normalize the result, the following
operation must be done: 

\rulex{5mm} 
{\tt L40\_norm\_v1 = L40\_shl( L40\_v1, norm\_L40( L40\_v1))}

\subsubsection{Multiplication operators}

%........................................................
\NewOperator{L40\_mult(v1, v2)}

Multiplies the 2 signed 16-bit variables v1 and v2 \textbf{without}
40-bit saturation control.  It will exit execution if it detects a 40-bit
overflow. The operation is performed \textbf{in fractional mode}:

\rulex{10mm} -- \pbox{150mm}{v1 and v2 are supposed to be in 1Q15 format.}

\rulex{10mm} -- \pbox{150mm}{The result is produced in 9Q31 format.}

%........................................................
\NewOperator{L40\_mac(L40\_v3, v1, v2)}

Equivalent to: {\tt L40\_add( L40\_v1, L40\_mult( v2, v3)) }

%........................................................
\NewOperator{L40\_msu(L40\_v3, v1, v2)}

Equivalent to: {\tt L40\_sub( L40\_v1, L40\_mult( v2, v3)) }

\subsubsection{Logical operators}

%........................................................
\NewOperator{L40\_lshl(L40\_v1, v2)}

Logically shifts left the 40-bit variable L40\_v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to
the least significant bits by (-v2) positions with insertion of 0 at
the most significant bit.} 

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to
the most significant bits by (v2) positions without saturation
control.} 

%........................................................
\NewOperator{L40\_lshr(L40\_v1, v2)}

Logically shifts right the 40-bit variable L40\_v1 by v2 positions:

\rulex{10mm} -- \pbox{150mm}{if v2 is positive, L40\_v1 is shifted to
the least significant bits by (v2) positions with insertion of 0 at
the most significant bit.} 

\rulex{10mm} -- \pbox{150mm}{if v2 is negative, L40\_v1 is shifted to
the most significant bits by (-v2) positions without saturation
control.} 

\subsubsection{Data type conversion operators}

%........................................................
\NewOperator{Extract40\_H(L40\_v1)}

Returns the bits [31..16] of L40\_v1.

%........................................................
\NewOperator{Extract40\_L(L40\_v1)}

Returns the bits [15..00] of L40\_v1.

%........................................................
\NewOperator{round40(L40\_v1)}

Equivalent to:\\
{\tt extract\_h( L\_saturate40( L40\_round( L40\_v1))) }

%........................................................
\NewOperator{L\_Extract40(L40\_v1)}

Returns the bits [31..00] of L40\_v1.

%........................................................
\NewOperator{L\_saturate40(L40\_v1)}

If L40\_v1 is greater than 2147483647, the operator returns 2147483647. \\
If L40\_v1 is lower than -2147483648, the operator returns -2147483648. \\
Otherwise, it is equivalent to {\tt L\_Extract40(L40\_v1)}.


%........................................................
\NewOperator{L40\_deposit\_h(v1)}

Deposits the 16-bit variable v1 in the bits [31..16] of the return
value: the return value bits [15..0] are set to 0 and the bits
[39..32] sign extend v1 sign bit.

%........................................................
\ \\
\NewOperator{L40\_deposit\_l(v1)}

Deposits the 16-bit variable v1 in the bits [15..0] of the return
value: the return value bits [39..16] sign extend v1 sign bit.

%........................................................
\NewOperator{L40\_deposit32(L\_v1)}

Deposits the 32-bit variable L\_v1 in the bits [31..0] of the
return value: the return value bits [39..32] sign extend L\_v1
sign bit.

%........................................................
\NewOperator{L40\_round(L40\_v1)}

Performs a rounding to the infinite on the 40-bit variable
L40\_v1. 32768 is added to L40\_v1 \textbf{without} 40-bit saturation
control. It will exit execution if it detects a 40-bit overflow.  The
end-result 16 LSBits are cleared to 0.


\subsection{Operators with complexity weight of 2}

%........................................................
\NewOperator{mac\_r40(L40\_v1, v2, v3)}

Equivalent to: \\
{\tt round40( L40\_mac( L40\_v1, v2, v3)) }

%........................................................
\NewOperator{msu\_r40(L40\_v1, v2, v3) }

Equivalent to: \\
{\tt round40( L40\_msu( L40\_v1, v2, v3)) }

%........................................................
\NewOperator{Mpy\_32\_16\_ss(L\_v1, v2, *L\_v3\_h, *v3\_l)}

\textbf{Multiplies the 2 signed values} L\_v1 (32-bit) and v2 (16-bit)
with saturation control on 48-bit. The operation is performed in
\textbf{fractional mode}: \\ 
When L\_v1 is in 1Q31 format, and v2 is in 1Q15 format, the result is
produced in 1Q47 format: L\_v3\_h bears the 32 most significant bits
while v3\_l bears the 16 least significant bits.

\subsection{Operators with complexity weight of 3}

%........................................................
\NewOperator{L40\_shr\_r(L40\_v1, v2)}

Arithmetically shifts the 40-bit variable L40\_v1 by v2 positions to
the least significant bits and rounds the result. It is equivalent to
{\tt L40\_shr( L40\_v1, v2)} except that if v2 is positive and the last
shifted out bit is 1, then the shifted result is increment by 1
\textbf{without} 40-bit saturation control. It will exit execution if
it detects a 40-bit overflow.

%........................................................
\newpage
\NewOperator{L40\_shl\_r(L40\_v1, v2)}

Arithmetically shifts the 40-bit variable L40\_v1 by v2 positions
to the most significant bits and rounds the result. It is
equivalent to {\tt L40\_shl( L40\_var1, v2)} except if v2 is negative.
In this case, it does the same as {\tt L40\_shr\_r( L40\_v1, (-v2))}.

%........................................................
\NewOperator{L40\_set(L40\_v1)}

Assigns a 40-bit constant to the returned 40-bit variable.

\subsection{Operators with complexity weight of 4}

%........................................................
\NewOperator{Mpy\_32\_32\_ss(L\_v1, L\_v2, *L\_v3\_h, *L\_v3\_l)}

Multiplies the two signed 32-bit values L\_v1 and L\_v2 with saturation
control on 64-bit. The operation is performed in \textbf{fractional
mode}: when L\_v1 and L\_v2 are in 1Q31 format, the result is produced
in 1Q63 format; L\_v3\_h bears the 32 most significant bits while
L\_v3\_l bears the 32 least significant bits.

\subsection{Coding Guidelines}

The following recommendations must be followed in the usage of the
40-bit operators:
\begin{enumerate}
\item Only 40-bit variables local to functions can be declared.
Declaration of arrays and structures containing 40-bit elements
must not be done.
\item 40-bit basic operators and 16/32-bit basic
operators must not be mixed within the same loop initialized with
a FOR(), DO or WHILE() control basic operator.

When nested loop software structure is implemented, this
recommendation applies to the most inner loops. This enables to
have, for instance, an outer loop containing 2 inner loops, with
the 1st inner loop using 40-bit basic operators and the 2nd inner
loop using 16/32-bit basic operators. However, whenever possible,
even such 2 level loop structure configuration should only use
either 40-bit basic operators or 16/32-bit basic operators.

Current version (2.0) of the operator implementation does not
evaluate the complexity associated to the mixing of 40-bit and
16/32-bit operators. Subsequent versions may do so.
\end{enumerate}

%-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
\section{Description of the control basic operators and associated weights}

This chapter describes the different control basic operators
available in the STL and their associated complexity weights. The
complexity values to be considered (as of the publication of the
STL2005) are the ones related to the version 2.0 of the library.
These basic operators did not exist in the previous version of the
library (version 1.x).

\textbf{A set of coding guidelines must be followed} in order to
avoid algorithm complexity miss-evaluation. This chapter describes
also these guidelines.

\subsection{Operators and complexity weights}
Nine macros are defined to enable the evaluation of the complexity
associated to control instructions that are frequently used in C.

\begin{list}{o}{}
\item The \textbf{IF(expression)} and \textbf{ELSE} macros
evaluate the cost of the C statement: if(expression) \{...\}[[
else if(expression2)\{...\}] else \{...\}] 
\item The \textbf{SWITCH(expression)} macro evaluates the cost of the C
statement: \\ switch(expression)\{...\}
\item The \textbf{WHILE(expression)} macro evaluates the cost of the C
statement: \\ while(expression) \{...\}
\item The \textbf{FOR(expr1;
expr2; expr3)} macro evaluates the cost of the C statement: for(
expr1; expr2; expr3) \{...\}
\item The \textbf{DO} and \textbf{WHILE(expression)} macros evaluates 
      the cost of the C statement: do \{...\} while(expression)
\item The \textbf{CONTINUE} macro evaluates the cost of the C statement:\\
\rulex{5mm}while(expression) \{\\
  \rulex{10mm}...\\
  \rulex{10mm}continue;\\
  \rulex{10mm}...\\
\rulex{5mm}\}\\
\rulex{5mm}\textbf{or}\\
\rulex{5mm}for( expr1; expr2; expr3)\\
\rulex{5mm}\{\\
  \rulex{10mm}...\\
  \rulex{10mm}continue;\\
  \rulex{10mm}...\\
\rulex{5mm}\}
\item The \textbf{BREAK} macro evaluates the cost of the C statement: \\
\rulex{5mm}while(expression) \\
\rulex{5mm}\{ \\
\rulex{10mm}... \\
\rulex{10mm}break;\\
\rulex{10mm}...\\
\rulex{5mm} \} \\
\rulex{5mm}\textbf{or} \\
\rulex{5mm}for( expr1; expr2; expr3) \\
\rulex{5mm}\{\\
\rulex{10mm}... \\
\rulex{10mm}break;\\
\rulex{10mm}...\\
\rulex{5mm} \} \\
\rulex{5mm}\textbf{or} \\
\rulex{5mm}switch(...) \{ \\
\rulex{10mm}...\\
\rulex{10mm}break;\\
\rulex{10mm}...\\
\rulex{5mm} \}
\item The \textbf{GOTO} macro evaluates the cost of the C statement: 
      goto label;

\end{list}

Table \ref{tbl:control-basicop} summarizes the control basic
operators and their associated complexity.

%-------------------------------------------------------------------------
% Table with the control basic operators and their associated complexity.
%-------------------------------------------------------------------------
\begin{table}[th]
\Caption{14cm}{\SF Control basic operators and associated
complexity. \label{tbl:control-basicop}}
\begin{center}
\footnotesize
\begin{tabular}{|c|l|l|}
\hline Complexity Weight  & Basic Operator  & Description\\
\hline \hline {0}    & \textbf{DO}\{...\} while(expression) &
\parbox[t]{70mm}{\SF The
macro DO must be used instead of the 'do' C statement.}\\
\hline {3} & \textbf{FOR}(expr1; expr2; expr3) \{...\} &
\parbox[t]{70mm}{\SF The macro FOR must be used instead of the
'for' C statement. The complexity is \textbf{independent} of the
number of loop iterations that are performed.} \\
\hline {0} & \parbox[t]{60mm}{\SF \textbf{if}(expression)
\textbf{one\_and\_only\_one\_basic\_operator (control operators
excluded)}} & \parbox[t]{70mm}{\SF \textbf{The macro IF must not
be used} when the 'if' structure does not have any 'else if' nor
'else' statement and it conditions only one basic operator
(control operators excluded)}. \\
\hline {4} & \parbox[t]{60mm}{\SF \textbf{IF}(expression) \{...\}}
&
\parbox[t]{70mm}{\SF The macro IF must be used instead of the 'if'
C statement \textbf{in every other case}: when there is an 'else'
or 'else if' statement, or when the 'if' conditions several basic
operators, or when the 'if' conditions a function call or when the
'if' conditions a control operator.}\\
\hline {4} & \parbox[t]{60mm}{\SF if(expression) \{...\} [[\\
\textbf{ELSE} if(expression2)\{...\}]\\ \textbf{ELSE} \{...\}]} &
\parbox[t]{70mm}{\SF The macro ELSE must be used instead of the
'else' C
statement.}\\
\hline {8} & \textbf{SWITCH}(expression) \{...\} &
\parbox[t]{70mm}{\SF The macro SWITCH must be used instead of the
'switch' C statement.}\\
\hline {4} & \textbf{WHILE}(expression) \{...\} &
\parbox[t]{70mm}{\SF The macro WHILE must be used instead of the
'while' C statement.\\
The complexity is \textbf{proportional} to the number of loop
iterations that are performed.}\\
\hline {4} & \parbox[t]{60mm}{\SF while(expression) \{ \\...
\textbf{CONTINUE}; ...\\ \}\\ or\\ for(expr1; expr2; expr3) \{
\\...\\ \textbf{CONTINUE}; \\...\\ \}\\ } &
\parbox[t]{70mm}{\SF The macro CONTINUE must be used instead of
the 'continue' C statement.}\\
\hline {4} & \parbox[t]{60mm}{\SF while(expression) \{ \\...
\textbf{BREAK}; ...\\ \}\\ or\\ for(expr1; expr2; expr3) \{
\\...\\ \textbf{BREAK}; \\...\\ \}\\or\\
switch(var) \{ \\...\\ \textbf{BREAK};\\...\\\}
 } &
\parbox[t]{70mm}{\SF The macro BREAK must be used instead of
the 'break' C statement.}\\
\hline {4} &  \textbf{GOTO}  & \parbox[t]{60mm}{\SF The macro GOTO
must be used instead of the 'goto' C statement.}\\
 \hline
\end{tabular}
\end{center}
\end{table}

%\flushfloats

\subsection{Coding guidelines}
\subsubsection{When to use IF() instead of if()?}

The \textbf{IF}() macro must be used instead of the classical C
statement \textbf{if}(), wherever:
\begin{list}{}
\item o There is an else or else if statement, \item o There is
\textbf{strictly more than one basic operator} to condition, \item
o There is at least a function call to condition. \item o There is
a control basic operator to condition.
\end{list}
Below example ...\\
\rulex{10mm}if( x == 0)\\
\rulex{15mm}z = \textbf{add}(z, \textbf{sub}(y, x));\\
\rulex{10mm}if( z == 0)\\
\rulex{15mm}Decode(); \\
\rulex{10mm}something(); \\

... must be written:\\
\rulex{10mm}\textbf{IF}( x == 0) \\
\rulex{15mm}z = \textbf{add}(z, \textbf{sub}(y, x));\\
\rulex{10mm}\textbf{IF}( z == 0)\\
\rulex{15mm}Decode();\\
\rulex{10mm}something(); \\

While below code must stay untouched since \textbf{only one} basic
operator
is conditioned.\\
\rulex{10mm}\textbf{if}( x == 0)\\
\rulex{15mm}z = \textbf{add}(z, x);\\
\rulex{10mm} something();

\subsubsection{When to use FOR() and WHILE() macros?} 

The FOR() and WHILE() macros must be used to differentiate loops which
can be handled by a h/w loop controller from complex loops which need
to be controlled by additional control software. 

\flushfloats

\begin{list}{o}
 \item Follows an example of a \textbf{simple h/w loop} that must
  be designed with the \textbf{FOR()} macro. It will iterate
  C-statement E0 to E20 a number of times \textbf{known at loop
  entry} (and at least once). Therefore, for such loops, there is no
  complexity associated to the computation of the decision to loop
  back or not:\\
  \rulex{20mm}/* \textbf{var1} $>$ 0 is ensured  */\\
  \rulex{20mm}FOR( n = 0; n $<$ var1; n++) \{\\
  \rulex{25mm}E0;\\
  \rulex{25mm}/* never do anything that impacts var1 nor n value */\\
  \rulex{25mm}E20;\\
  \rulex{20mm}\} \end{list}
  \begin{list}{o}
   \item Follows an example of a \textbf{complex s/w loop} that must be
         designed with the \textbf{WHILE()}. It will iterate C-statement E0 to
         E20 a number of times \textbf{undefined} at loop entry (eventually 0
         times). Indeed, at the end of one loop iteration, the decision to loop
         back depends on the processing done within the elapsed iteration.\\ 
        \rulex{20mm}/* do not need to ensure \textbf{n $<$ var1} at loop
        entry */ \\
        \rulex{20mm}WHILE(\textbf{n $<$ var1}) \{\\
        \rulex{25mm}E0;\\
        \rulex{25mm}/* can do anything that impacts \textbf{var1} or
        \textbf{n} value */\\
        \rulex{25mm}E20;\\
        \rulex{20mm}\}
  \end{list}

 ANSI-C defines \textbf{for}() structures with \textbf{while}()
 structures, but by differencing the \textbf{FOR}() and
 \textbf{WHILE}() macro usage, a better complexity evaluation of
 the loop controlling is made. 

 \begin{list}{}
 \item o A loop defined with FOR() macro: 
  \begin{list}{}
   \item - \textbf{Only counts the initial set-up} of the h/w loop controller with a complexity weight of 3. 
   \item - \textbf{Must iterate at least once}. 
   \item - Has a complexity \textbf{independent} of the number of iterations that are performed.
  \end{list}
 \item o A Loop defined with WHILE() macro: 
  \begin{list}{}
   \item - Counts, at \textbf{every single iteration} which is executed,
\textbf{the complexity associated to the computation of the
decision to loop back or not}.
   \item - \textbf{Can be executed 0 times.}
   \item - Has a complexity \textbf{proportional} (by a factor
of  4) to the number of iterations that are performed.
  \end{list}
\end{list}

\subsubsection{When to use DO and WHILE() macros?}

It is important to \textbf{modify} below C code:\\
\rulex{10mm}do \{\\
\rulex{15mm}x = sub(x, y)\\
\rulex{10mm}\} while( x $<$ 0);\\

... into following one: \\
\rulex{10mm}\textbf{DO} \{\\
\rulex{15mm}x = sub(x, y)\\
\rulex{10mm}\} \textbf{WHILE}( x $<$ 0);

The following code is also possible but, although the associated
complexity computation will be identical, it can generate parsing
errors by some source code editors which perform on-the-fly syntax
checking.\\
\rulex{10mm}do \{ \\
\rulex{15mm}x = sub(x, y) \\
\rulex{10mm}\} WHILE(x $<$ 0);

\subsubsection {Testing an expression equality}

\textbf{\emph{if(expression) \{...\} and while(expression) \{...\}
C statements.}}

All arithmetic tests on data must be presented as a comparison to
zero. To perform comparison between two variables (or a variable
and a non-zero constant), a subtraction (\textbf{sub} or
\textbf{L\_sub} or \textbf{L40\_sub}) must be performed first.

For example, below examples leads to an under evaluation of the
complexity: \\
\rulex{10mm}if( a $>$ 3 ) \{\} \\
\rulex{10mm}while( a != 5) \{\} ...

While, below examples leads to a correct evaluation of the
complexity: 

\rulex{10mm}if( sub(a,3) $>$ 0) \{\}\\
\rulex{10mm}while( sub( a, 5) != 0) \{\} ...

If multiple condition need to be evaluated and merged, one
\textbf{test}() operator must be used for each additional test to be
done.

Example 1:

The following code ...

\rulex{10mm}if ( (a $>$ b) \&\& (c $>$ d)) \{\}

... must be modified to:

\rulex{10mm}\textbf{test}(); \\
\rulex{10mm}if ( (sub( a, b) $>$ 0) \&\& (sub( c, d) $>$ 0)) \{\}

Example 2:

The following code ...\\
\rulex{10mm}if ( (a $>$ b) \\
\rulex{10mm}\&\& (c $>$ d) \\
\rulex{10mm}$||$(e $>$ f)) \{\}

... must be modified to:\\
\rulex{10mm}\textbf{test}(); \\
\rulex{10mm}\textbf{test}(); \\
\rulex{10mm}if (  (sub( a, b) $>$ 0)\\
\rulex{10mm}\&\& ( sub( c, d) $>$ 0)\\
\rulex{10mm}$||$ (sub( e, f) $>$ 0)) \{\}\\

\ \\
\textbf{\emph{(condition) ? (statement1) : (statement2)}}

The ternary operator ``\textbf{? \ :}'' must not be used since it does
not enable the evaluation of the associated complexity. 

Therefore, instead of writing: \\
\rulex{10mm}(condition) ? (statement1) : (statement2)

One must write: \\
\rulex{10mm}IF(condition)\\
\rulex{15mm}{statement1};\\
\rulex{10mm}ELSE\\
\rulex{15mm}{statement2};

Whenever it is possible to avoid the \textbf{else} clause, one should write:\\
\rulex{10mm}{statement2};\\
\rulex{10mm}IF(condition)\\
\rulex{15mm}{statement1};

And whenever \textbf{statement1} is \textbf{one and only one basic
operator} (control operator excluded), one can write:\\
\rulex{10mm}{statement2};\\
\rulex{10mm}if(condition)\\
\rulex{15mm}{one\_and\_only\_one\_basic\_operator};\\

\textbf{\emph{for(expresion1; expression2; expression3)}}

A \textbf{"for"} C statement must be limited to initializing, testing and
incrementing the loop counter. The following C code statement is an
example of incorrect usage:

\rulex{10mm}for(i=0, j=0; i$<$N \& w$>$0 ; i++, j+=3)

It must be replaced by: \\
\rulex{10mm}j=0;\\
\rulex{10mm}for(i=0; i$<$N ; i++) \{\\
\rulex{15mm}j = add(j,3);\\
\rulex{15mm}if(w $>$ 0)\\
\rulex{18mm}break; \\
\rulex{10mm}\}

Actually, in order to respect the other recommendations, it must
be replaced by: \\
\rulex{10mm}j=0;\\
\rulex{10mm}FOR(i=0; i$<$N ; i++) \{\\
\rulex{15mm}j = add(j,3);\\
\rulex{15mm}if(w $>$ 0)\{\\
\rulex{18mm}BREAK; \\
\rulex{15mm}\}\\
\rulex{10mm}\}


\section{Complexity associated with data moves and other operations}

\subsection{Data moves}

Each data move between two 16-bit variables (with
\textbf{move16}() operator) has a complexity weight of 1 and each
data move between two 32-bit variables (with \textbf{move32}()
operator) has a complexity weight of 2.

\begin{tabular}{ll}
1. &  A 16-bit variable cannot be directly moved to a 32-bit or 40-bit variable.\\
2. &  A 32-bit variable cannot be directly moved to a 16-bit or 40-bit variable.\\
3. &  A 40-bit variable cannot be directly moved to a 16-bit or 32-bit variable.\\
\end{tabular}

For above 3 types of moves, functions such as the following ones
must be used:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\hline round() & round40()   & L\_saturate40()\\
\hline extract\_h() & Extract40\_H()   & L\_Extract40()\\
\hline extract\_l() & Extract40\_L()   & L40\_deposit32()\\
\hline L\_deposit\_h()   & L40\_deposit\_h() & \\
\hline L\_deposit\_l()   & L40\_deposit\_l() & \\
\hline
\end{tabular}
\end{center}

There will be no extra weighting for data move when using above
functions: the weighting of the data move is already included in
the weighting of these functions.

Data moves are only counted in
the following cases:\\
\begin{tabular}{ll}
1. &  A data move from a constant to a variable; \\
2. &  A data move from a variable to a variable; \\
3. &  A data move of the result of a basic operation to an array
variable; \\
4. &  When an arithmetic test is performed on an array variable.
\end{tabular}

\subsection{Other operations}

Address computation must be excluded from the complexity
evaluation. However, when extremely complex address computations
are done, these address computations should be resolved using the
basic operations, in order to account for the associated
complexity.

%----------------------------------------------------------------------
\section{Complexity evaluation tool for floating point C Code}
%----------------------------------------------------------------------

\subsection{Introduction}
The Complexity evaluation tool for floating point C Code enables to 
estimate the number of WMOPS (Weighted Million Operations per Second) 
and Program ROM of a floating point implementation of speech and audio 
codecs. Also an estimation of the complexity that would be obtained 
after conversion of a floating point source code into the corresponding 
fixed point implementation is computed.

\subsection{Tool Description }
This tool consists of complexity counters (macros) collected in an ANSI 
C library. The library is intended to be included in a codec algorithm, 
each line of which is instrumented with the complexity counters. The 
tool measures the computational complexity and program ROM based on a 
floating point C source code instrumented with the counters. Note that 
RAM and table ROM have to be estimated by other means. 

The tool is meant to provide a consistent, platform independent method 
of obtaining and reporting complexity estimates. The weights assigned 
with arithmetic operations reflect as much as possible those of the 
ITU-T Fixed point Basic Operators. It should be noted, however, that the methodology 
cannot give an exact correspondence with the complexity of the fixed 
point implementation and only estimation is given. Among several other 
reasons, this is because the scaling related operations (including 
saturation and overflow control) used in the fixed point implementation 
have no correspondence in the floating point implementation.

The essential feature of the tool is that the instructions need to be 
executed to be counted. Therefore the codec should be executed in 
conditions that give the broadest possible coverage of the source code 
(i.e. usually at the highest bitrate in frame-error conditions).

\subsection{Complexity Verification Method}
The computational complexity associated with a given speech and audio 
codec can be specified in terms of the number of instructions required 
per frame. The type and number of operations returned by the algorithm 
on a per-frame basis are specified for both the encoder and the 
decoder. Algorithms are broken down into sub-processing elements, each 
having a detailed breakdown of the types of operations and the number 
of operations required to complete the sub-processing element. Certain 
operations require several instructions in order to be computed. Thus 
all operations have associated with them a weight, indicative of this 
expansion, and given in Table \ref{tbl:flp-counters} (column 
Complexity Weights).

The total number of instructions required per frame is then given by 
summing the total number of weighted operations. This number represents 
the basic computational complexity of the codec in instructions per 
frame. The complexity in WMOPS is then obtained by dividing the number 
of operations per frame by the length of the frame in seconds. The 
complexity estimates are computed assuming average and worst case 
number of operations both per frame and per second. The complexity 
is computed separately for the encoder and the decoder.

The operation count performed for the complexity measurement is re-used 
to get an estimate of the program memory. This operation count specifies 
operations in loops, loop counters, operations in subroutines, and 
subroutine counters. Each operation is weighted using the memory weights 
from the Table \ref{tbl:flp-counters} (column Memory Weights) to produce 
a memory usage in words. Operations inside loops are counted only once. 
Similarly operations inside subroutines are counted only once.

\subsection{Tool implementation}
The tool consists of one header file \textit{flc.h} and one ANSI C library 
file \textit{flc.c}. Both files must be included into the project to use 
this tool. Further, the code must be instrumented using counters defined 
in the Table \ref{tbl:flp-counters} (column Counter). Finally the following 
functions are needed:
\begin{itemize}
	\item To initialize internal data structures, the function 
	\textit{FLC\_init()} must be called before any counters are defined, 
	usually at the beginning of the codec algorithm.
	\item The function \textit{FLC\_frame\_update()} must be called at the 
	end of the frame loop in order the FLC tool can keep track of the 
	per-frame maxima to evaluate the worst-case conditions.
	\item The function \textit{FLC\_end()} computes and prints the complexity 
	of the program and is called usually at the end of the codec algorithm.
	\item The separate complexity of subroutine/subsection is estimated by 
	calling the function \textit{FLC\_sub\_start(name\_of\_subroutine)} that 
	must be matched with calling the function \textit{FLC\_sub\_end()} at 
	the end of the subsection/subroutine.
\end{itemize}

Note that once the code is instrumented using the complexity counters and 
functions, the compilation switch DONT\_COUNT can be activated to suppress 
the functionality of the tool with no need of removing the complexity 
counters and functions from the code.

\subsection{Scaling factor}
A scaling factor is used to estimate and print the complexity that would be 
obtained after conversion of a floating point source code into the 
corresponding fixed point implementation. The scaling factor (FLC\_SCALEFAC) 
is defined in file \textit{flc.h} and its value is set to 1.1.

\subsection{List of complexity measurement counters}

\begin{center}
\tablefirsthead{
\hline
Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)\\
\hline}
\tablehead{
\hline
\multicolumn{5}{|l|}{\small\sl continued from previous page}\\
\hline
Operation&Counter&Example&Complexity Weights (Cycles)&Memory Weights (words)\\
\hline}
\tabletail{
\hline
\multicolumn{5}{|r|}{\small\sl continued on next page}\\
\hline}
\tablelasttail{\hline}
\bottomcaption{\SF Complexity Measurement Counters
		\label{tbl:flp-counters}}
\begin{supertabular}{|m{4cm}|m{2.2cm}|m{3.6cm}|m{3.6cm}|m{2cm}|}
\hline
Addition	& ADD()	& a=b+c	& 1	& 1\\
\hline
Multiplication	& MULT()	& a=b*c &	1	& 1 \\
\hline
Multiplication-Addition	& MAC() &	a+=b*c	& 1 &	1 \\
\hline
Move	& MOVE()	& a=b, a[i]=b[i] ONLY assignment or copy	& 1 &	1 \\
\hline
Storing Arithmetic Result in Array	& STORE()	& a[i]=b[i]+c[i]	& 1 (for move only)	& 0\\
\hline
Logical	& LOGIC()	 & AND, OR, etc.	& 1 &	1 \\
\hline
Shift	& SHIFT()	& a=b$>>$c	& 1 &	1 \\
\hline
Branch (tested with zero)	& BRANCH()	& if, if...then...else...Count 1 
BRANCH for each "if" possibility	& 4 &	2 \\
\hline
Division & DIV() &	a=b/c, a=b\%c & 18	& 2 \\
\hline
Square-root	& SQRT()	&a=sqrt(b), a=isqrt(b), a=1/sqrt(b)	& 10	& 2\\
\hline
Transcendental	& TRANS()	& sine, log, arctan	& 25 & 2\\
\hline
Function call	& FUNC()	& a=func(b, c, d) &	2+i, where i=number of arguments passed \& returned	& 2\\
\hline
Loop initialization	&LOOP()	&for (i=0; i$<$n; i++)&	3	&1\\
\hline
\multirow{3}{*}{Indirect addressing}& \multirow{3}{*}{INDIRECT()}	& a=b.c, a=b[c], a=b[c][d],
a=*b, a=*(b+c) & \multirow{3}{*}{2}	&\multirow{3}{*}{2}\\
& & st$->$array & 	& \\
& & st$->$value	&	&\\
\hline
Pointer initialization &	PTR\_INIT()	&a[i]	&1 (charged outside the loop)	&1\\
\hline
Double Precision Addition	&DADD()	&a=b+c	&2&	1\\
\hline
Double Precision Multiplication	&DMULT()	&a=b*c	& 2&	1\\
\hline
Double Precision Move	&DMOVE()	&a=b&	2	&1\\
\hline
Double Precision Division	&DDIV()&	a=b/c	&36&	2\\
\hline
Exponential	& POWER()	& pow, 1.0/x, exp(n)	&25	&2 \\
\hline
Logarithm	&LOG()&	log2, log10, Ln	&25	&2\\
\hline
Extra conditional test& 	TEST()&	used in conjunction with BRANCH &	2	&1\\
\hline
All other operations&	MISC()&	e.g. ABS&	1	&1\\
\hline
\end{supertabular}
\end{center}

\subsection{Examples of instrumentation of the code}
The rules to compute the complexity are general and when they are 
implemented, some choices must be done. Table \ref{tbl:flp-usage}
contains some examples to show where the counters should be placed.

\begin{center}
\tablefirsthead{
\hline
Operation	& Counter used &	Explanation	& Reference \\
\hline}
\tablehead{
\hline
\multicolumn{4}{|l|}{\small\sl continued from previous page}\\
\hline
Operation	& Counter used &	Explanation	& Reference \\
\hline}
\tabletail{
\hline
\multicolumn{4}{|r|}{\small\sl continued on next page}\\
\hline}
\tablelasttail{\hline}
\bottomcaption{\SF Usage of complexity measurement counters
         \label{tbl:flp-usage}}
\renewcommand{\arraystretch}{1.5}
\begin{supertabular}{|m{4.5cm}|m{4.5cm}|m{4cm}|m{2.5cm}|}
\hline
if (a!=b $||$ c==d)\{...\}	& ADD(2); BRANCH(1); TEST(1);	&
BRANCH for if, TEST for additional condition, ADD for 
two tests against non-zero value	&\\
\hline
if (a!=b \&\& c==d)\{\} else if( a==c )\{\} & ADD(3); 
BRANCH(2);TEST(1); & & \\
\hline
b = a / L	& MULT(1); &	When L is constant; (1/L) is a constant too,
So b = a * (1/L)	& \\
\hline
*a = *b	& MOVE(1);	& Copy 	& Table \ref{tbl:flp-counters}, Move\\
\hline
for(i=0;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& LOOP(1);(before)
ADD(1); STORE(1);(inside)	& When a loop begins with an offset, 
initialization of pointer is counted	 & \\
for(i=c;i$<$L;i++) \{x[i]=a[i]+b[i];\}	& PTR\_INIT(3), LOOP(1); (before)
 ADD(1); STORE(1); (inside)	& 	& \\
\hline
\&pt = \&(a+L)	& PTR\_INIT(1);	& if L is constant and b is variable, 
ADD is counted		& \\
\&pt = \&(a+b)	&ADD(1); PTR\_INIT(1);	& & \\
\hline
a=func(b) or a[i]=func(b)	& FUNC(2);	&The value returned by function is counted in FUNC(). 
MOVE or STORE are not counted in that case	&\\
\hline
a = *b	& INDIRECT(1);	& &	Table \ref{tbl:flp-counters}, Pointer Initialization \\
for(i=0;i$<$L;i++) \{a=*b++;\} a=*b;	& MOVE(1) in the loop MOVE(1) outside the loop	
& Use of MOVE outside the loop because the pointer is already initialized
&	Table \ref{tbl:flp-counters}, Move \\
\hline
pt\_a += M	& PTR\_INIT(1);	& M is constant, so this is equivalent to pt\_a=\&pt\_a+M	&\\
\hline
pt\_a += m	& ADD(1); PTR\_INIT(1);	& m is variable, so this is equivalent to  pt\_a=\&pt\_a+m	& \\
\hline
*a=0.99*b	& MULT(1); STORE(1); &	A mathematical result is stored with a pointer & \\
for(i=0;i$<$L;i++) \{a=*b+a;\} & PTR\_INIT(1); (before loop) ADD(1); (inside)	
& If a pointer is initialized before the loop, no need to count INDIRECT(1) inside
& \\
\hline	
a[b][c]=x[y][z]	& MOVE(1);	& &	Table \ref{tbl:flp-counters}, Move \\
\hline
switch(a)\{
case b:break;
case c: break;
default:break; 
\} & ADD(2); BRANCH(2) before switch	& Can be replaced by
if (a==b) \{...\} else if(a==c) \{...\} else \{...\} & \\
\hline
& & &\\
st$->$a[0]=t[2]; & INDIRECT(2); 	& \multirow{3}{4cm}{Use INDIRECT(2) to remove 
double indirection and call MOVE(2) to copy data}	& \\
st$->$a[1]=t[3];	& MOVE(2) & & \\
& & &\\
%& & &\\
%& & &\\
\hline
(*rnd\_T0)++	& ADD(1); STORE(1);	&it can be replaced by 
*rnd\_T0=*rnd\_T0+1;	& \\	
\hline
pit\_shrp( code,  &	FUNC(4);&	  \multirow{2}{4cm}{*round\_T0 is passed by indirection}	&\\
PIT\_SHARP, *round\_T0, L\_SUBFR); &	INDIRECT(1);& 	&\\
\hline
indice[0] = & \multirow{2}{*}{INDIRECT(2);}	& \multirow{2}{*}{Double indirection} &\\
indirect\_dico1[indice[0]];	& & &\\
\hline
sqr = indice[0] +indice[1] +indice[2] +indice[3] +indice[4];&	PTR\_INIT(1);
ADD(4);	&Can be done in a loop	&\\
\hline
\end{supertabular}
\end{center}

\subsection{Tests and Portability}
Compiled and tested on a PC (Windows XP) platform with MS Visual C++ 2005 and 
in Cygwin with gcc (version 3.4.4).

\subsection{Example code}
A demonstration program, \textit{flc\_example.c}, serves as an example and 
guideline for the illustration of the tool usage. To compile a 
demonstration program, Windows MSVC and Cygwin gcc makefiles 
are enclosed in the subdirectory \textit{workspace}.

Below you can find the output screen when executing the demonstration program.

===== Call Graph and total ops per function =====\\
\begin{tabular}{lrrr}
Function         &            Calls         &     Ops      &   Ops/Call \\
-----------&&&\\
ROOT          &                   1        &        0        &        0\\
-Autocorr       &               100       &    975900         &    9759\\
--Set\_Zero       &              200      &       4100          &   20.5\\
-Lev\_dur          &             100     &       99600           &   996\\
\end{tabular}

===== Program Memory Usage by Function =====\\

\begin{tabular}{lrrrrrrrrr}
Function       &     ADD  &MULT &  MAC & MOVE &STORE &LOGIC &SHIFT &BRNCH &  DIV\\
----------- &&&&&&&&&\\
Set\_Zero      &        0    & 0 &    0    & 1 &    0    & 0 &    0   &  0&     0\\
Autocorr       &       1   &  4  &  17   &  0  &  21   &  0  &   0  &   2 &    0\\
Lev\_dur         &      0  &   2   &  5  &   5   &  3  &   0   &  1 &    1  &   2\\
ROOT             &     0 &    0    & 0 &    0    & 0 &    0    & 0&     0   &  0\\
-----------&&&&&&&&&\\
totals          &      1  &   6 &   22   &  6  &  24   &  0   &  1   &  3  &   2\\
\end{tabular}
--------------------------------\\

\begin{tabular}{lrrrrrrr}
Function          & SQRT &TRANC & FUNC & LOOP  & IND &  PTR  &MISC\\
----------- &&&&&&&\\
Set\_Zero    &          0  &   0&     0   &  1&     0  &   1&     0\\
Autocorr      &        0  &   0  &   2   &  2  &   1  &   6  &   0\\
Lev\_dur       &        0&     0  &   0 &    3  &   4&     5  &   0\\
ROOT            &      0&     0    & 2 &    0    & 0&     0    & 0\\
-----------&&&&&&&\\
totals                &0   &  0   &  4   &  6   &  5   & 12  &   0\\
\end{tabular}


===== SUMMARY =====\\
Total Ops: 1.0796e+06\\
Total Program ROM usage: 83  (word)\\


===== Per Frame Summary =====\\
Number of Frames: 100\\
Average Ops/frame: 10796.00   Max Ops/frame: 10796\\


===== ESTIMATED COMPLEXITY (Frame length is 20.00 ms) =====\\
Maximum complexity: 0.539800 WMOPS\\
Average complexity: 0.539800 WMOPS\\

Estimated fixed point complexity with 1.1 scaling factor:\\
Maximum complexity: 0.593780 WMOPS\\
Average complexity: 0.593780 WMOPS\\



